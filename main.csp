#include "rook.csp";
#include "king.csp";
#include "queen.csp";
#include "bishop.csp";
#include "pawn.csp";
#include "knight.csp";

//#include "testboard1.csp";
//#include "board1.csp";
//#include "board2.csp";
//#include "board3.csp";
//#include "board4.csp";
//#include "board5.csp";
#include "board6.csp";

#import "ValidityCheck";

// the game starts with white to play
game() = whiteMove();

whiteMove() = [numMoves <= 2] whitePlan();
blackMove() = [numMoves <= 2] blackPlan();

// each side can move any of its pieces
whitePlan() = whiteKing() [] whiteRook() [] whiteQueen() [] whiteBishop() [] whitePawn() [] whiteKnights();
blackPlan() = blackKing() [] blackRook() [] blackQueen() [] blackBishop() [] blackPawn() [] blackKnights();

execute() = 
	[currentTurn == 1] whiteToPlay {
		// current player no longer in check if move was legal
		checkStatus[currentTurn] = 0;
		// change turn
		currentTurn = 1 - currentTurn;	
		// increase numMoves
		numMoves = 1 + numMoves;
	} -> whiteInCheck()
	[]
	[currentTurn == 0] blackToPlay {
		// current player no longer in check if move was legal
		checkStatus[currentTurn] = 0;
		// change turn
		currentTurn = 1 - currentTurn;	
		// increase numMoves
		numMoves = 1 + numMoves;
	} -> blackInCheck();

// updates the check status for the side that is about to play
blackInCheck = [call(isCheck, currentTurn, actualBoard, piecePosition[BLACK_KING][RANK], piecePosition[BLACK_KING][FILE])]
			blackIsInCheck {checkStatus[currentTurn] = 1;} -> blackMove()
			[]
			[!call(isCheck, currentTurn, actualBoard, piecePosition[BLACK_KING][RANK], piecePosition[BLACK_KING][FILE])]
			blackIsNotInCheck {checkStatus[currentTurn] = 0;} -> blackMove();

whiteInCheck = [call(isCheck, currentTurn, actualBoard, piecePosition[WHITE_KING][RANK], piecePosition[WHITE_KING][FILE])]
			whiteIsInCheck {checkStatus[currentTurn] = 1;} -> whiteMove()
			[]
			[!call(isCheck, currentTurn, actualBoard, piecePosition[WHITE_KING][RANK], piecePosition[WHITE_KING][FILE])]
			whiteIsNotInCheck {checkStatus[currentTurn] = 0;} -> whiteMove();
		
#define goal_queen actualBoard[RANK_1][FILE_D] == WHITE_QUEEN && 
								piecePosition[WHITE_QUEEN][RANK] == RANK_1 && piecePosition[WHITE_QUEEN][FILE] == FILE_D;
#assert game() reaches goal_queen;								
#define goal currentTurn == 1;
#assert game() reaches goal;

#define blackNotInCheck checkStatus[1] == 0;
#define blackCheck checkStatus[1] == 1;
#define blackTurn currentTurn == BLACK_TURN;
#define whiteHasMoved numMoves == 1;
#define impossible numMoves == 4;
#define whiteTurnAgain numMoves >= 2;
#define blackAlwaysIllegal blackIllegal == 1;
#define blackAlwaysLegal blackIllegal == 0 && blackNoMoves == 0;
#define whiteAlwaysIllegal whiteIllegal == 1 || whiteNoMoves == 1;

#assert game() |= blackCheck R whiteTurnAgain;
#assert game() reaches blackCheck;
#assert game() |= []!(<> blackTurn && <> blackCheck && !<>[](whiteTurnAgain));
#assert game() |= []!((<>blackCheck) U whiteTurnAgain);
#assert game() |= ((<>blackCheck) U []!whiteTurnAgain);
#assert game() |= []!(whiteHasMoved && blackCheck && ([]<>(blackAlwaysIllegal)));

#assert game() |= !(impossible);
#assert game() |= <>[](whiteTurnAgain || blackNotInCheck);
