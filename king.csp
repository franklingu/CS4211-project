#include "board.csp";

blackKingUp() = [currentTurn == BLACK_TURN]moveOnce(BLACK_KING, 1, 0);
blackKingDown() = [currentTurn == BLACK_TURN]moveOnce(BLACK_KING, -1, 0);
blackKingRight() = [currentTurn == BLACK_TURN]moveOnce(BLACK_KING, 0, 1);
blackKingLeft() = [currentTurn == BLACK_TURN]moveOnce(BLACK_KING, 0, -1);
blackKingUpLeft() = [currentTurn == BLACK_TURN]moveOnce(BLACK_KING, 1, -1);
blackKingUpRight() = [currentTurn == BLACK_TURN]moveOnce(BLACK_KING, 1, 1);
blackKingDownLeft() = [currentTurn == BLACK_TURN]moveOnce(BLACK_KING, -1, -1);
blackKingDownRight() = [currentTurn == BLACK_TURN]moveOnce(BLACK_KING, -1, 1);

blackKing() = blackKingUp() [] blackKingRight() [] blackKingDown() [] blackKingLeft() []
              blackKingUpLeft() [] blackKingUpRight() [] blackKingDownLeft() [] blackKingDownRight();

whiteKingUp() = [currentTurn == WHITE_TURN]moveOnce(WHITE_KING, 1, 0);
whiteKingDown() = [currentTurn == WHITE_TURN]moveOnce(WHITE_KING, -1, 0);
whiteKingRight() = [currentTurn == WHITE_TURN]moveOnce(WHITE_KING, 0, 1);
whiteKingLeft() = [currentTurn == WHITE_TURN]moveOnce(WHITE_KING, 0, -1);
whiteKingUpLeft() = [currentTurn == WHITE_TURN]moveOnce(WHITE_KING, 1, -1);
whiteKingUpRight() = [currentTurn == WHITE_TURN]moveOnce(WHITE_KING, 1, 1);
whiteKingDownLeft() = [currentTurn == WHITE_TURN]moveOnce(WHITE_KING, -1, -1);
whiteKingDownRight() = [currentTurn == WHITE_TURN]moveOnce(WHITE_KING, -1, 1);

whiteKing() = whiteKingUp() [] whiteKingRight() [] whiteKingDown() [] whiteKingLeft() []
              whiteKingUpLeft() [] whiteKingUpRight() [] whiteKingDownLeft() [] whiteKingDownRight();

#define goalSuccessWhiteKingUp piecePosition[WHITE_KING][0] == RANK_2 && piecePosition[WHITE_KING][1] == FILE_E &&
						actualBoard[RANK_2][FILE_E] == WHITE_KING;
#define goalSuccessWhiteKingUpLeft piecePosition[WHITE_KING][0] == RANK_2 && piecePosition[WHITE_KING][1] == FILE_D &&
							actualBoard[RANK_2][FILE_D] == WHITE_KING;
#define goalSuccessWhiteKingUpRight piecePosition[WHITE_KING][0] == RANK_2 && piecePosition[WHITE_KING][1] == FILE_F &&
							 actualBoard[RANK_2][FILE_F] == WHITE_KING;
#define goalSuccessWhiteKingLeft piecePosition[WHITE_KING][0] == RANK_1 && piecePosition[WHITE_KING][1] == FILE_D &&
						  actualBoard[RANK_1][FILE_D] == WHITE_KING;
#define goalFailureWhiteKingRightSelfPiece piecePosition[WHITE_KING][0] == RANK_1 && piecePosition[WHITE_KING][1] == FILE_F;

#assert whiteKing() reaches goalSuccessWhiteKingUp;
#assert whiteKing() reaches goalSuccessWhiteKingUpLeft;
#assert whiteKing() reaches goalSuccessWhiteKingUpRight;
#assert whiteKing() reaches goalSuccessWhiteKingLeft;
#assert whiteKing() reaches goalFailureWhiteKingRightSelfPiece;

#define goalSuccessBlackKingDownRightEnemyPiece piecePosition[BLACK_KING][0] == RANK_7 && piecePosition[BLACK_KING][1] == FILE_F &&
										 actualBoard[RANK_7][FILE_F] == BLACK_KING;
#define goalFailureBlackKingDownSelfPiece piecePosition[BLACK_KING][0] == RANK_7 && piecePosition[BLACK_KING][1] == FILE_E;
#define goalFailureBlackKingDownLeftSelfPiece piecePosition[BLACK_KING][0] == RANK_7 && piecePosition[BLACK_KING][1] == FILE_D;
#define goalSuccessBlackKingRight piecePosition[BLACK_KING][0] == RANK_8 && piecePosition[BLACK_KING][1] == FILE_F &&
						   actualBoard[RANK_8][FILE_F] == BLACK_KING;
#define goalSuccessBlackKingLeft piecePosition[BLACK_KING][0] == RANK_8 && piecePosition[BLACK_KING][1] == FILE_D &&
						   actualBoard[RANK_8][FILE_D] == BLACK_KING;

moveBlacKing() = changeTurnToBlack{currentTurn = BLACK_TURN;} -> blackKing();

#assert moveBlacKing() reaches goalSuccessBlackKingDownRightEnemyPiece;
#assert moveBlacKing() reaches goalFailureBlackKingDownSelfPiece;
#assert moveBlacKing() reaches goalFailureBlackKingDownLeftSelfPiece;
#assert moveBlacKing() reaches goalSuccessBlackKingRight;
#assert moveBlacKing() reaches goalSuccessBlackKingLeft;
