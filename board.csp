#define BOARD_SIZE 8;
#define RANK 0;
#define FILE 1;

#define WHITE_PAWN_1 1;
#define WHITE_PAWN_2 2;
#define WHITE_PAWN_3 3;
#define WHITE_PAWN_4 4;
#define WHITE_PAWN_5 5;
#define WHITE_PAWN_6 6;
#define WHITE_PAWN_7 7;
#define WHITE_PAWN_8 8;

#define WHITE_QUEENS_ROOK 9;
#define WHITE_QUEENS_KNIGHT 10;
#define WHITE_QUEENS_BISHOP 11;
#define WHITE_QUEEN 12;                                                      //        0....................7
#define WHITE_KING 13;                                                       //        a  b  c  d  e  f  g  h              (files)
#define WHITE_KINGS_BISHOP 14;                                               // 7 8    25 26 27 28 29 30 31 32     BLACKS
#define WHITE_KINGS_KNIGHT 15;                                               // . 7    17 18 19 20 21 22 23 24
#define WHITE_KINGS_ROOK 16;                                                 // . 6
                                                                             // . 5
#define BLACK_PAWN_1 17;                                                     // . 4
#define BLACK_PAWN_2 18;                                                     // . 3
#define BLACK_PAWN_3 19;                                                     // . 2    1  2  3  4  5  6  7  8
#define BLACK_PAWN_4 20;                                                     // 0 1    9 10  11 12 13 14 15 16      WHITES
#define BLACK_PAWN_5 21;                                                     //        R  N  B  Q  K   B  N  R
#define BLACK_PAWN_6 22;                                                     //
#define BLACK_PAWN_7 23;                                                     //(ranks)
#define BLACK_PAWN_8 24;

#define BLACK_QUEENS_ROOK 25;
#define BLACK_QUEENS_KNIGHT 26;
#define BLACK_QUEENS_BISHOP 27;
#define BLACK_QUEEN 28;
#define BLACK_KING 29;
#define BLACK_KINGS_BISHOP 30;
#define BLACK_KINGS_KNIGHT 31;
#define BLACK_KINGS_ROOK 32;

#define FILE_A 0;
#define FILE_B 1;
#define FILE_C 2;
#define FILE_D 3;
#define FILE_E 4;
#define FILE_F 5;
#define FILE_G 6;
#define FILE_H 7;

#define RANK_1 0;
#define RANK_2 1;
#define RANK_3 2;
#define RANK_4 3;
#define RANK_5 4;
#define RANK_6 5;
#define RANK_7 6;
#define RANK_8 7;

#define WHITE_TURN 0;
#define BLACK_TURN 1;

#define DEAD -1;

var currentTurn = WHITE_TURN;

// piece position keeps track of each piece's position
var piecePosition[33][2] = [-1, -1, // 0 - dummy
							-1, -1, // 1
							-1, -1, 
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							RANK_1, FILE_A, // 9 white queens's rook
							-1, -1,
							RANK_1, FILE_C, // 11 white queens's bishop
							-1, -1,
							RANK_1, FILE_E, // white king
							RANK_1, FILE_F, // white king's bishop
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1, // 20
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							-1, -1,
							RANK_8, FILE_E, // black king
							-1, -1, // 30
							-1, -1, // 31
							-1, -1 // 32
							];

var actualBoard[BOARD_SIZE][BOARD_SIZE] = [		WHITE_QUEENS_ROOK,	0,	WHITE_QUEENS_BISHOP,	0,	WHITE_KING,	WHITE_KINGS_BISHOP,	0,	0,
		   		 						  		0,		0,		0,			0,		0,		0,	0,	0,
		   		 						  		0,		0,		0,			0,		0,		0,	0,	0,
		   		 						  		0,		0,		0,			0,		0,		0,	0,	0,
		   		 						  		0,		0,		0,			0,		0,		0,	0,	0,
		   		 						  		0,		0,		0,			0,		0,		0,	0,	0,
		   		 						  		0,		0,		0,			0,		0,		0,	0,	0,
		   		 						  		0,		0,		0,			0,	BLACK_KING,	0,	0,	0
		   		 						 ];
		   		 
moveContinuous(piece, up, right) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD )
{
	// movement is within board
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
		{
			// if space is empty
			if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] == 0){
				move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> moveContinuous(piece, up, right) [] validateWhite()
			}
			// if target is occupied by a black piece
			else if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1){
				eat{
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> validateWhite()
			}
			else {Stop}
		} else {
			Stop
		}
	}else{Stop};
		
moveOnce(piece, up, right) = if (piecePosition[piece][RANK] != -1 && piecePosition[piece][FILE] != -1 )
{
	// movement is within board
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
		{
			// if space is empty
			if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] == 0 || 
				actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1){
					move{
						// update the old position
						actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
						// update new position
						piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
						piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
						actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> validateWhite()
			}}
};

movePawnDiagonal(piece, up, right) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD)
{
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
	{
		if (actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1) {
			eat{
				actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
				piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
				piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
				actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
			} -> validateWhite()
		}
		else { Stop }
	}
	else { Stop }
};

movePawnDouble(piece, up) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD)
{
	if (piecePosition[piece][RANK] == 1 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE]] == 0) {
		move{
				// update the old position
				actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
				// update new position
				piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
				actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
		} -> validateWhite()
	}
	else { Stop }
};
										  
validateWhite() = Stop;

// sample assertions
moveRookRight() = moveContinuous(WHITE_QUEENS_ROOK, 0, 1);
#assert moveRookRight() reaches goal;

moveRookUp() = moveContinuous(WHITE_QUEENS_ROOK, 1, 0);
#assert moveRookUp() reaches goal_2;

moveKingUp() = moveOnce(WHITE_KING, 1, 0);
#assert moveKingUp() reaches goal_3;

moveKingDown() = moveOnce(WHITE_KING, -1, 0);
#assert moveKingDown() reaches goal_3;

#define goal actualBoard[RANK_1][FILE_D] == WHITE_QUEENS_ROOK;
#define goal_2 actualBoard[RANK_4][FILE_A] == WHITE_QUEENS_ROOK;
#define goal_3 actualBoard[RANK_2][FILE_E] == WHITE_KING;
