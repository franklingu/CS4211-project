#define BOARD_SIZE 8;
#define RANK 0;
#define FILE 1;

#define WHITE_PAWN_1 1;
#define WHITE_PAWN_2 2;
#define WHITE_PAWN_3 3;
#define WHITE_PAWN_4 4;
#define WHITE_PAWN_5 5;
#define WHITE_PAWN_6 6;
#define WHITE_PAWN_7 7;
#define WHITE_PAWN_8 8;

#define WHITE_QUEENS_ROOK 9;
#define WHITE_QUEENS_KNIGHT 10;
#define WHITE_QUEENS_BISHOP 11;
#define WHITE_QUEEN 12;                                                      //        0....................7
#define WHITE_KING 13;                                                       //        a  b  c  d  e  f  g  h              (files)
#define WHITE_KINGS_BISHOP 14;                                               // 7 8    25 26 27 28 29 30 31 32     BLACKS
#define WHITE_KINGS_KNIGHT 15;                                               // . 7    17 18 19 20 21 22 23 24
#define WHITE_KINGS_ROOK 16;                                                 // . 6
                                                                             // . 5
#define BLACK_PAWN_1 17;                                                     // . 4
#define BLACK_PAWN_2 18;                                                     // . 3
#define BLACK_PAWN_3 19;                                                     // . 2    1  2  3  4  5  6  7  8
#define BLACK_PAWN_4 20;                                                     // 0 1    9 10  11 12 13 14 15 16      WHITES
#define BLACK_PAWN_5 21;                                                     //        R  N  B  Q  K   B  N  R
#define BLACK_PAWN_6 22;                                                     //
#define BLACK_PAWN_7 23;                                                     //(ranks)
#define BLACK_PAWN_8 24;

#define BLACK_QUEENS_ROOK 25;
#define BLACK_QUEENS_KNIGHT 26;
#define BLACK_QUEENS_BISHOP 27;
#define BLACK_QUEEN 28;
#define BLACK_KING 29;
#define BLACK_KINGS_BISHOP 30;
#define BLACK_KINGS_KNIGHT 31;
#define BLACK_KINGS_ROOK 32;

#define FILE_A 0;
#define FILE_B 1;
#define FILE_C 2;
#define FILE_D 3;
#define FILE_E 4;
#define FILE_F 5;
#define FILE_G 6;
#define FILE_H 7;

#define RANK_1 0;
#define RANK_2 1;
#define RANK_3 2;
#define RANK_4 3;
#define RANK_5 4;
#define RANK_6 5;
#define RANK_7 6;
#define RANK_8 7;

#define WHITE_TURN 0;
#define BLACK_TURN 1;

#define DEAD -1;

var currentTurn = WHITE_TURN;

// piece position keeps track of each piece's position
var piecePosition[33][2] = [DEAD, DEAD, // 0 - dummy
							DEAD, DEAD, // 1 white pawn 1
							DEAD, DEAD, // 2 white pawn 2
							DEAD, DEAD, // 3 white pawn 3
							RANK_6, FILE_D, // 4 white pawn 4
							DEAD, DEAD, // 5 white pawn 5
							RANK_6, FILE_F, // 6 white pawn 6
							DEAD, DEAD, // 7 white pawn 7
							DEAD, DEAD, // 8 white pawn 8
							RANK_2, FILE_A, // 9 white queens's rook
							DEAD, DEAD, // 10 white queen's knight
							RANK_1, FILE_C, // 11 white queens's bishop
							RANK_4, FILE_E, // 12 white queen
							RANK_1, FILE_E, // 13 white king
							RANK_1, FILE_F, // 14 white king's bishop
							RANK_7, FILE_F, // 15 white king's knight
							DEAD, DEAD, // 16 white king's rook
							RANK_7, FILE_A, // 17 black pawn 1
							DEAD, DEAD, // 18 black pawn 2
							RANK_6, FILE_C, // 19 black pawn 3
							DEAD, DEAD, // 20 black pawn 4
							RANK_7, FILE_E, // 21 black pawn 5
							DEAD, DEAD, // 22 black pawn 6
							RANK_5, FILE_G, // 23 black pawn 7
							DEAD, DEAD, // 24 black pawn 8
							RANK_5, FILE_A, // 25 black queen's rook
							RANK_6, FILE_A, // 26 black queen's knight
							DEAD, DEAD, // 27 black queen's bishop
							RANK_7, FILE_D, // 28 black queen
							RANK_8, FILE_E, // 29 black king
							RANK_5, FILE_C, // 30 black king's bishop
							DEAD, DEAD, // 31 black king's knight
							RANK_1, FILE_H // 32 black king's rook
							];

var actualBoard[BOARD_SIZE][BOARD_SIZE] = [		0,	0,	WHITE_QUEENS_BISHOP,	0,	WHITE_KING,	WHITE_KINGS_BISHOP,	0,	BLACK_KINGS_ROOK,
		   		 						  		WHITE_QUEENS_ROOK,		0,		0,			0,		0,		0,	0,	0,
		   		 						  		0,		0,		0,			0,		0,		0,		0,		0,
		   		 						  		0,		0,		0,			0,		WHITE_QUEEN,		0,	0,	0,
		   		 						  		BLACK_QUEENS_ROOK,		0,		BLACK_KINGS_BISHOP,			0,		0,		0,	BLACK_PAWN_7,	0,
		   		 						  		BLACK_QUEENS_KNIGHT,		0,		BLACK_PAWN_3,			WHITE_PAWN_4,		0,		WHITE_PAWN_6,	0,	0,
		   		 						  		BLACK_PAWN_1,		0,		0,			BLACK_QUEEN,		BLACK_PAWN_5,		WHITE_KINGS_KNIGHT,	0,	0,
		   		 						  		0,		0,		0,			0,	BLACK_KING,	0,	0,	0
		   		 						 ];
				 
moveContinuous(piece, up, right) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD )
{
	// movement is within board
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
		{
			// if space is empty
			if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] == 0)
			{
				move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> moveContinuous(piece, up, right) [] validateWhite()
			}
			// if target is occupied by a black piece and you are white
			else if((piece <= WHITE_KINGS_ROOK && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1) ||
					(piece >= BLACK_PAWN_1 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] <= WHITE_KINGS_ROOK))
			{
				eat{
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> validateWhite()
			}			
			else {Stop}
		} else {
			Stop
		}
	}else{Stop};
		
moveOnce(piece, up, right) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD )
{
	// movement is within board
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
		{
			if (piece >= WHITE_PAWN_1 && piece <= WHITE_KINGS_ROOK) 
			{
				// if space is empty
				if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] == 0 || 
					actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1)
				{
						move{
							// update the old position
							actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
							// update new position
							piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
							piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
							actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
							} -> validateWhite()
				}
			}
			else 
			{
				// if space is empty
				if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] <= WHITE_KINGS_ROOK)
				{
						move{
							// update the old position
							actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
							// update new position
							piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
							piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
							actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
						} -> validateWhite()
				}
			}
		}
};


movePawnOnce(piece, up) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD )
{
	// movement is within board, taking advantage of pawns are never on the final row of either side
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1)
		{
			// if space is empty
			if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE]] == 0)
			{
				move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
					} -> validateWhite()
			}
		}
};

movePawnDiagonal(piece, up, right) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD)
{
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
	{
	  if(piece <= WHITE_PAWN_8)
	  {
			if (actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1)                    //if target is occupied by black pieces then white pawns can kill it
			{
				eat{
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> validateWhite()
			}
			else { Stop }
	  }
	  else if(piece >= BLACK_PAWN_1)
	  {
	        if (actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] > 0 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] <= WHITE_KINGS_ROOK)                //if target is occupied by white pieces then black pawns can kill it
			{
				eat{
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> validateBlack()
			}
			else { Stop }
	  }
	}
	else { Stop }
};

movePawnDouble(piece, up) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD)
{
   if(piece <= WHITE_PAWN_8)
   {	
		if (piecePosition[piece][RANK] == RANK_2 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE]] == 0 &&
			actualBoard[piecePosition[piece][RANK] + up + up][piecePosition[piece][FILE]] == 0)       //RANK_2 is the initial rank for the white pawns
		{
			move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up + up;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
			} -> validateWhite()
		}
		else { Stop }
	}
	else if(piece >= BLACK_PAWN_1)
	{
	    if (piecePosition[piece][RANK] == RANK_7 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE]] == 0 &&
			actualBoard[piecePosition[piece][RANK] + up + up][piecePosition[piece][FILE]] == 0)       //RANK_7 is the initial rank for the black pawns
		{
			move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up + up;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
			} -> validateBlack()
		}
		else { Stop }
	}
};
										  
validateWhite() = Stop;
validateBlack() = Stop;

// sample assertions
moveRookRight() = moveContinuous(WHITE_QUEENS_ROOK, 0, 1);
#assert moveRookRight() reaches goal;

moveRookUp() = moveContinuous(WHITE_QUEENS_ROOK, 1, 0);
#assert moveRookUp() reaches goal_2;

moveKingUp() = moveOnce(WHITE_KING, 1, 0);
#assert moveKingUp() reaches goal_3;

moveKingDown() = moveOnce(WHITE_KING, -1, 0);
#assert moveKingDown() reaches goal_3;

#define goal actualBoard[RANK_1][FILE_D] == WHITE_QUEENS_ROOK;
#define goal_2 actualBoard[RANK_4][FILE_A] == WHITE_QUEENS_ROOK;
#define goal_3 actualBoard[RANK_2][FILE_E] == WHITE_KING;
