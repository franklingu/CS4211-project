#include "constants.csp";
#include "board1.csp";
//#include "board2.csp"
//#include "board3.csp"
//#include "board4.csp"
//#include "board5.csp"
//#include "board6.csp"
				 
moveContinuous(piece, up, right) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD )
{
	// movement is within board
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
		{
			// if space is empty
			if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] == 0)
			{
				move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> moveContinuous(piece, up, right) [] validateWhite()
			}
			// if target is occupied by a black piece and you are white
			else if((piece <= WHITE_KINGS_ROOK && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1) ||
					(piece >= BLACK_PAWN_1 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] <= WHITE_KINGS_ROOK))
			{
				eat{
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> validateWhite()
			}			
			else {Stop}
		} else {
			Stop
		}
	}else{Stop};
		
moveOnce(piece, up, right) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD )
{
	// movement is within board
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
		{
			if (piece >= WHITE_PAWN_1 && piece <= WHITE_KINGS_ROOK) 
			{
				// if space is empty
				if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] == 0 || 
					actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1)
				{
						move{
							// update the old position
							actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
							// update new position
							piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
							piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
							actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
							} -> validateWhite()
				}
			}
			else 
			{
				// if space is empty
				if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] <= WHITE_KINGS_ROOK)
				{
						move{
							// update the old position
							actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
							// update new position
							piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
							piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
							actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
						} -> validateWhite()
				}
			}
		}
};


movePawnOnce(piece, up) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD )
{
	// movement is within board, taking advantage of pawns are never on the final row of either side
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1)
		{
			// if space is empty
			if(actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE]] == 0)
			{
				move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
					} -> validateWhite()
			}
		}
};

movePawnDiagonal(piece, up, right) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD)
{
	if ( piecePosition[piece][RANK] + up >= 0 && piecePosition[piece][RANK] + up <= BOARD_SIZE - 1 &&
		piecePosition[piece][FILE] + right >= 0 && piecePosition[piece][FILE] + right <= BOARD_SIZE - 1 )
	{
	  if(piece <= WHITE_PAWN_8)
	  {
			if (actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] >= BLACK_PAWN_1)                    //if target is occupied by black pieces then white pawns can kill it
			{
				eat{
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> validateWhite()
			}
			else { Stop }
	  }
	  else if(piece >= BLACK_PAWN_1)
	  {
	        if (actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] > 0 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE] + right] <= WHITE_KINGS_ROOK)                //if target is occupied by white pieces then black pawns can kill it
			{
				eat{
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up;
					piecePosition[piece][FILE] = piecePosition[piece][FILE] + right;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
				} -> validateBlack()
			}
			else { Stop }
	  }
	}
	else { Stop }
};

movePawnDouble(piece, up) = if (piecePosition[piece][RANK] != DEAD && piecePosition[piece][FILE] != DEAD)
{
   if(piece <= WHITE_PAWN_8)
   {	
		if (piecePosition[piece][RANK] == RANK_2 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE]] == 0 &&
			actualBoard[piecePosition[piece][RANK] + up + up][piecePosition[piece][FILE]] == 0)       //RANK_2 is the initial rank for the white pawns
		{
			move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up + up;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
			} -> validateWhite()
		}
		else { Stop }
	}
	else if(piece >= BLACK_PAWN_1)
	{
	    if (piecePosition[piece][RANK] == RANK_7 && actualBoard[piecePosition[piece][RANK] + up][piecePosition[piece][FILE]] == 0 &&
			actualBoard[piecePosition[piece][RANK] + up + up][piecePosition[piece][FILE]] == 0)       //RANK_7 is the initial rank for the black pawns
		{
			move{
					// update the old position
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = 0;
					// update new position
					piecePosition[piece][RANK] = piecePosition[piece][RANK] + up + up;
					actualBoard[piecePosition[piece][RANK]][piecePosition[piece][FILE]] = piece;
			} -> validateBlack()
		}
		else { Stop }
	}
};
										  
validateWhite() = Stop;
validateBlack() = Stop;
